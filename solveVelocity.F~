c -*- Mode: Fortran; -*-
c-----------------------------------------------------------------
c     Ravi Samtaney
c     Copyright 2011
c     King Abdullah University of Science and Technology
c     All Rights Reserved
c-----------------------------------------------------------------
c     $Log: solveVelocity2.F,v $
c     Revision 1.8  2011/10/31 12:08:58  samtanr
c     Extrpolated u,v,w at x=xouter.
c     For now set u,p direchlet bc on upper boundary.
c
c     Revision 1.7  2011/10/28 09:03:14  samtanr
c     One flat plate bc now instead of channel.
c
c     Revision 1.4  2011/10/18 13:02:58  samtanr
c     Added code to handle inflow velocity to be function of y,z.
c
c     Revision 1.3  2011/10/08 13:38:43  samtanr
c     Fixed minor issues in GS.
c
c     Revision 1.2  2011/10/03 08:18:29  samtanr
c     Intermediate checkin.
c
c     Revision 1.1  2011/07/25 11:32:01  samtanr
c     Original source.
c
c     Wind code: Incompressible Navier-Stokes LES
c
c-----------------------------------------------------------------
c
c     Comments about the array sizes:
c     One choice was to use different arrays for u,v,w components
c     of velocity since these are not collocated. However, with a 
c     view to parallelization of the code, it was thought that
c     using a uniform size for each velocity component, while
c     slightly wasteful in terms of memory, would lead to 
c     smaller number of messages passed during exchange routines.
c     Each message however will be larger because we will be
c     exchanging 3 ghost nodes - again a little wasteful but probably
c     leads to better communication performance.
c
      module MGParamsv
      save
      integer, parameter:: lmax=0
      integer:: bchFlag
      integer:: xchangeFlag
      end module MGParamsv

      module VelParameters
      save
      type LevelData
        double precision:: nu
        double precision:: delx, dely, delz
      end type levelData
      type(LevelData), allocatable:: ldata(:)
      double precision:: aa,bb,cc
      end module VelParameters
c
c
      module VelocityFieldSolver
      contains
       subroutine SolveHelmholtz(uu,rhsu,nu)
       use mesh
       use mesh_common
       use properties
       use VelParameters
       use mgparamsv
       use iounits
#ifdef PARALLEL
        use mpistuff
#endif
c
       implicit none
c
c       integer:: neqn 
#ifndef TWO_D
       double precision:: uu(-2:nxlocal+3,-2:nylocal+3,-2:nzlocal+3,3)
       double precision:: rhsu(1:nxlocal+1,1:nylocal+1,1:nzlocal+1,3)
#else
       double precision:: uu(-2:nxlocal+3,nylocal,-2:nzlocal+3,3)
       double precision:: rhsu(1:nxlocal+1,nylocal,1:nzlocal+1,3)
#endif

       double precision:: nu
c
c       integer:: i,j,k,l
c
c
c
c       write(6,*) 'Solve Vel nu=', nu
c       write(6,*) 'Solve Vel rhsu=', minval(rhsu),maxval(rhsu)
c       write(6,*) 
c       write(6,*) 
c     WC pointed out that nu should be as below (9/3/11)
c       nu=beta*dt/Reynolds
c       nu=0.00D0
c       uu(:,:,:,1)=0.D0
c       rhsu(:,:,:,1)=0.D0
c       uu(:,:,:,2:3)=0.D0
c       rhsu(:,:,:,2:3)=0.D0
c       nu=1.D0
c        return
       call SetVelParameters(lmax,nu)
c 
       call SolveEllipticEquation(uu,rhsu,3)
c
c       write(6,*) 
c       write(6,*) 
       deallocate(ldata)
       return
       end subroutine
c

c-----------------------------------------------------------------------
      subroutine SetVelParameters(lmax,nu)
c
      use VelParameters
      use mesh
      use properties
      implicit none
      integer:: lmax
c      integer:: i,j,k,imax,jmax,kmax
      integer:: l
      double precision:: nu
c
c     Allocate lmax levels of data
      allocate(ldata(0:lmax))
c
      ldata(0)%delx=dxi
      ldata(0)%dely=dyi
      ldata(0)%delz=dzi
c
c      ldata(0)%delt=dt
      do l=1,lmax,1
         ldata(l)%delx=0.5D0*ldata(l-1)%delx
         ldata(l)%dely=0.5D0*ldata(l-1)%dely
         ldata(l)%delz=0.5D0*ldata(l-1)%delz
c   
c         ldata(l)%delt=dt
      enddo
c
c     Set the viscosity*dt
      do l=0,lmax,1
         ldata(l)%nu=nu
      enddo
      aa=16.D0/12.D0
      bb=-30.D0/12.D0
      cc=-1.D0/12.D0
c      aa=1.D0
c      bb=-2.D0
c      cc=0.D0
      return
      end subroutine
c-----------------------------------------------------------------------
      subroutine LaplaceVel(vx,rhs,imax,jmax,kmax,
     &     neqn,level,xChangeFlag)
c
      use properties
      use VelParameters
c
      implicit none
c
      integer:: imax,jmax,kmax,level,xChangeFlag 
      integer:: neqn
#ifndef TWO_D
      double precision:: vx(-2:imax+3,-2:jmax+3,-2:kmax+3,neqn)
      double precision:: rhs(imax+1,jmax+1,kmax+1,neqn)
#else
      double precision:: vx(-2:imax+3,jmax,-2:kmax+3,neqn)
      double precision:: rhs(imax+1,jmax,kmax+1,neqn)
#endif
c
c      double precision:: nu
      double precision:: dxi,dyi,dzi
c     
      integer:: i,j,k  !,l
c
      dxi=ldata(level)%delx**2
      dyi=ldata(level)%dely**2
      dzi=ldata(level)%delz**2
c
      rhs=0.D0
c     x-component
      do k=1,kmax,1
         do j=1,jmax,1
            do i=1,imax+1,1
               rhs(i,j,k,1)=(cc*(vx(i+2,j,k,1)+vx(i-2,j,k,1))
     &                   +aa*(vx(i+1,j,k,1)+vx(i-1,j,k,1))
     &                   +bb*vx(i,j,k,1))*dxi+
#ifndef TWO_D
     &              (cc*(vx(i,j+2,k,1)+vx(i,j-2,k,1))
     &                   +aa*(vx(i,j+1,k,1)+vx(i,j-1,k,1))
     &                   +bb*vx(i,j,k,1))*dyi+
#endif
     &              (cc*(vx(i,j,k+2,1)+vx(i,j,k-2,1))
     &                   +aa*(vx(i,j,k+1,1)+vx(i,j,k-1,1))
     &                   +bb*vx(i,j,k,1))*dzi
c               rhs(i,j,k)=(vx(i+1,j,k)+vx(i-1,j,k)
c     &                   -2.D0*vx(i,j,k))*dxi+
c     &              (vx(i,j+1,k)+vx(i,j-1,k)
c     &                   -2.D0*vx(i,j,k))*dyi+
c     &              (vx(i,j,k+1)+vx(i,j,k-1)-2.D0
c     &                   *vx(i,j,k))*dzi
c
            enddo
         enddo
      enddo
c
c     y-component
#ifndef TWO_D
      do k=1,kmax,1
         do j=1,jmax+1,1
            do i=1,imax,1
               rhs(i,j,k,2)=(cc*(vx(i+2,j,k,2)+vx(i-2,j,k,2))
     &                   +aa*(vx(i+1,j,k,2)+vx(i-1,j,k,2))
     &                   +bb*vx(i,j,k,2))*dxi+
     &              (cc*(vx(i,j+2,k,2)+vx(i,j-2,k,2))
     &                   +aa*(vx(i,j+1,k,2)+vx(i,j-1,k,2))
     &                   +bb*vx(i,j,k,2))*dyi+
     &              (cc*(vx(i,j,k+2,2)+vx(i,j,k-2,2))
     &                   +aa*(vx(i,j,k+1,2)+vx(i,j,k-1,2))
     &                   +bb*vx(i,j,k,2))*dzi
c
            enddo
         enddo
      enddo
#else
      rhs(:,:,:,2)=0.D0
#endif      
c     z-component
      do k=1,kmax+1,1
         do j=1,jmax,1
            do i=1,imax,1
               rhs(i,j,k,3)=(cc*(vx(i+2,j,k,3)+vx(i-2,j,k,3))
     &                   +aa*(vx(i+1,j,k,3)+vx(i-1,j,k,3))
     &                   +bb*vx(i,j,k,3))*dxi+
#ifndef TWO_D
     &              (cc*(vx(i,j+2,k,3)+vx(i,j-2,k,3))
     &                   +aa*(vx(i,j+1,k,3)+vx(i,j-1,k,3))
     &                   +bb*vx(i,j,k,3))*dyi+
#endif
     &              (cc*(vx(i,j,k+2,3)+vx(i,j,k-2,3))
     &                   +aa*(vx(i,j,k+1,3)+vx(i,j,k-1,3))
     &                   +bb*vx(i,j,k,3))*dzi
c
            enddo
         enddo
      enddo
c
c
      return
      end subroutine
c     
c-----------------------------------------------------------------------
      subroutine ApplyOperatorVel(vel,res,imax,jmax,kmax,neqn,level,dx)
      use VelParameters
      use mgparamsv
      implicit none
      integer:: imax,jmax,kmax,level,neqn
      double precision:: dx(3)
#ifndef TWO_D
      double precision:: vel(-2:imax+3,-2:jmax+3,-2:kmax+3,neqn)
      double precision:: res(-2:imax+3,-2:jmax+3,-2:kmax+3,neqn)
#else
      double precision:: vel(-2:imax+3,jmax,-2:kmax+3,neqn)
      double precision:: res(-2:imax+3,jmax,-2:kmax+3,neqn)
#endif
c
c     Local vars
#ifndef TWO_D
      double precision:: lapvel(imax+1,jmax+1,kmax+1,neqn)
#else
      double precision:: lapvel(imax+1,jmax,kmax+1,neqn)
#endif
c     
      integer:: i,j,k
c
      if (bcHFlag.eq.0) then
         call BC3D(vel,dx,imax,jmax,kmax,xChangeFlag)
      else
         call BCHomogeneous3D(vel,imax,jmax,kmax,xChangeFlag)
      endif
      Call ExchangePsi3D(vel,imax,jmax,kmax,neqn,xChangeFlag)
c
c     This doesn't need const nu
      call LaplaceVel(vel,lapvel,imax,jmax,kmax,neqn,level,xChangeFlag)
c
         res=0.D0
c
         do k=1,kmax,1
            do j=1,jmax,1
               do i=1,imax+1,1
                  res(i,j,k,1)=vel(i,j,k,1)-
     &                 ldata(level)%nu*lapvel(i,j,k,1)
               enddo
            enddo
         enddo
c
#ifndef TWO_D
         do k=1,kmax,1
            do j=1,jmax+1,1
               do i=1,imax,1
                  res(i,j,k,2)=vel(i,j,k,2)-
     &                 ldata(level)%nu*lapvel(i,j,k,2)
               enddo
            enddo
         enddo
#else
         res(:,:,:,2)=0.D0
#endif
c
         do k=1,kmax+1,1
            do j=1,jmax,1
               do i=1,imax,1
                  res(i,j,k,3)=vel(i,j,k,3)-
     &                 ldata(level)%nu*lapvel(i,j,k,3)
               enddo
            enddo
         enddo
c
         return
         end subroutine
c-----------------------------------------------------------------------
      subroutine BCHomogeneous3D(vel,imax,jmax,kmax,xChangeFlag)
c-----------------------------------------------------------------------
c     Description: 
c     Homogeneous Dirichlet BCs for psi in x
c     Homogeneous Neumann BCs for psi in y
c     Homogeneous Neumann BCs for psi in z
c     Input: psi - solution
c            imax,jmax,kmax: mesh size at this level
c            xChangeFlag - whether we are doing this on 1 or many procs.
c     Output: psi: Modified at the ghost cells at physical boundaries
c     
c-----------------------------------------------------------------------
      use mesh_uparms
      use mesh_common
       implicit none
      integer:: imax,jmax,kmax
      integer:: xChangeFlag
#ifndef TWO_D
      double precision:: vel(-2:imax+3,-2:jmax+3,-2:kmax+3,3)
#else
      double precision:: vel(-2:imax+3,jmax,-2:kmax+3,3)
#endif
      call XBCH(vel,imax,jmax,kmax,3)
#ifndef TWO_D
      call YBCPeriodic(vel,imax,jmax,kmax,3)
#endif
      call ZBCH(vel,imax,jmax,kmax,3)
      return
      end subroutine

c-----------------------------------------------------------------------
      subroutine BC3D(vel,dx,imax,jmax,kmax,xChangeFlag)
c-----------------------------------------------------------------------
c     Homogeneous Dirichlet BCs for psi in x
c     Homogeneous Neumann BCs for psi in y
c     Important to make the distinction with the 
c     BCHomogeneous routine in case we have different BCs.
c     Input: psi - solution
c     imax,jmax: mesh size at this level
c     xChangeFlag - whether we are doing this on 1 or many procs.
c     Output: psi: Modified at the ghost cells at physical boundaries
c     
c-----------------------------------------------------------------------
      use mesh_uparms
      use mesh_common
       implicit none
      integer:: imax,jmax,kmax
      integer:: xChangeFlag
#ifndef TWO_D
      double precision:: vel(-2:imax+3,-2:jmax+3,-2:kmax+3,3)
#else
      double precision:: vel(-2:imax+3,jmax,-2:kmax+3,3)
#endif
      double precision:: dx(3)
c      integer:: i,j,k,l
c     
c     
      call XBC(vel,imax,jmax,kmax,3)
#ifndef TWO_D
      call YBCPeriodic(vel,imax,jmax,kmax,3)
#endif
      call ZBC(vel,imax,jmax,kmax,3)
      return
      end subroutine

c-----------------------------------------------------------------------
       subroutine SolveEllipticEquation(psi,res,neqn)  !!psi is uu, res is rhsu Eq(5), neqn is = 3
c-----------------------------------------------------------------
c     Input: res - RHS of the equations L(phi)=res
c     Implicit Input: lMax and lMaxLocal which are determined 
c                     outside of this subroutine, are the
c                     maximum no of global and local levels, resp.
c     Output: phi
c     Multigrid implementation
c     Author: Ravi Samtaney
c     Assumed parameters: No of presmooth and postsmooth iterations 
c                         set to 10.
c                         Convergence tolerance set to 10^-12
c                         Max no. of V-cycles =10. 
c    
c     
c     
       use mesh
       use properties
       use mesh_common
       use iounits
#ifdef PARALLEL
      use mpistuff
#endif
      use MGParamsv
c     
       implicit none
c=======Declarations=========
c        double precision:: dt
c
        integer:: neqn
#ifndef TWO_D
        double precision:: 
     &       psi(-2:nxlocal+3,-2:nylocal+3,-2:nzlocal+3,neqn)
        double precision:: res(1:nxlocal+1,nylocal+1,nzlocal+1,neqn)
#else
        double precision:: 
     &       psi(-2:nxlocal+3,nylocal,-2:nzlocal+3,neqn)
        double precision:: res(1:nxlocal+1,nylocal,nzlocal+1,neqn)
#endif
c
c        double precision,allocatable:: psi(:,:,:,:)
c        double precision,allocatable:: psi0(:,:,:,:)
#ifndef TWO_D
        double precision:: 
     &       psi0(-2:nxlocal+3,-2:nylocal+3,-2:nzlocal+3,neqn)
        double precision:: resx(nxlocal+1,nylocal+1,nzlocal+1,neqn)
#else
        double precision:: 
     &       psi0(-2:nxlocal+3,nylocal,-2:nzlocal+3,neqn)
        double precision:: resx(nxlocal+1,nylocal,nzlocal+1,neqn)
#endif
c
c        integer:: indx,indy
c        integer:: i,j,k,l
        integer:: maxOuterIter
        integer:: iter, doMG
c
        double precision:: resMax
        double precision:: tolerance
        double precision:: dxl(3)
c
        doMg=1
        maxOuterIter=10
cc
        bcHFlag=0
        xChangeFlag=1
        resMax=1.D16
        tolerance=1.D-8
        iter=1
c     Set initial mesh spacing here
        dxl(1)=dx
        dxl(2)=dy
        dxl(3)=dz
c
        resx=0.D0
c
c        write(6,*) 'Res',minval(res),maxval(res),neqn
        call Residual3D(psi,res,resx,nxlocal,nylocal,nzlocal,neqn,0,dxl)
#ifndef TWO_D
        call MaxNorm3D(resx,nxlocal+1,nylocal+1,nzlocal+1,neqn,resMax)
#else
        call MaxNorm3D(resx,nxlocal+1,nylocal,nzlocal+1,neqn,resMax)
#endif
c
c        if(iprocx.eq.1.and.iprocy.eq.1.and.iprocz.eq.1) then
c           write(6,*) 'Initial Vel Max Norm 3D Residual=',resMax
c        endif
c
        call BC3D(psi,dxl,nxlocal,nylocal,nzlocal,0)
        psi0=psi
c        write(6,*) 'Sum psi', sum(psi), sum(psi0)
c
        if(doMG.eq.1) then
        do while(iter.le.maxOuterIter.and.resMax.gt.tolerance)
           call MGSolve3D(psi,psi0,res,nxlocal,nylocal,nzlocal,neqn,
     &          0,dxl)      !!psi is uu,psi0=psi, res is rhsu Eq(5), neqn is 3
c           call BC3D(psi,dxl,nxlocal,nylocal,nzlocal,0)
c           write(6,*) 'Sum psi', sum(psi), sum(psi0)
           psi0=psi
           resx=0.D0
           call Residual3D(psi,res,resx,nxlocal,nylocal,nzlocal,neqn,
     &          0,dxl)
#ifndef TWO_D
        call MaxNorm3D(resx,nxlocal+1,nylocal+1,nzlocal+1,neqn,resMax)
#else
        call MaxNorm3D(resx,nxlocal+1,nylocal,nzlocal+1,neqn,resMax)
#endif
           if(iprocx.eq.1.and.iprocy.eq.1.and.iprocz.eq.1) then
              write(6,*) 'Vel Max Norm 3D Residual=',iter,resMax
     &           , iprocx,iprocz
           endif
           iter=iter+1
        enddo
c     else use G-S
        else
           call GaussSeidel(psi0,psi,res,50,nxlocal,nylocal,nzlocal,
     &          neqn, 0,dxl)
        endif
c
        call Residual3D(psi,res,resx,nxlocal,nylocal,nzlocal,neqn,0,dxl)
#ifndef TWO_D
        call MaxNorm3D(resx,nxlocal+1,nylocal+1,nzlocal+1,neqn,resMax)
#else
        call MaxNorm3D(resx,nxlocal+1,nylocal,nzlocal+1,neqn,resMax)
#endif
        if(iprocx.eq.1.and.iprocy.eq.1.and.iprocz.eq.1) then
           write(ihis,*) 'Final Vel Max Norm 3D Residual=',iter-1,resMax
c           write(6,*) 'Final Vel Max Norm 3D Residual=',iter-1,resMax
        endif
        return
        end subroutine
c     

c     
c-----------------------------------------------------------------------
      recursive subroutine MGSolve3D(psi,psiT,res,
     &     imax,jmax,kmax,neqn,
     &     level,dx)
      use MGParamsv
      use mesh_uparms
      use mesh_common
      implicit none
      integer:: imax,jmax,kmax,neqn,level
      integer:: imaxg,jmaxg,kmaxg
#ifndef TWO_D
      double precision:: psi(-2:imax+3,-2:jmax+3,-2:kmax+3,neqn)
      double precision:: psiT(-2:imax+3,-2:jmax+3,-2:kmax+3,neqn)
      double precision:: res(imax+1,jmax+1,kmax+1,neqn)
      double precision:: resCorr(imax+1,jmax+1,kmax+1,neqn)
#else
      double precision:: psi(-2:imax+3,jmax,-2:kmax+3,neqn)
      double precision:: psiT(-2:imax+3,jmax,-2:kmax+3,neqn)
      double precision:: res(imax+1,jmax,kmax+1,neqn)
      double precision:: resCorr(imax+1,jmax,kmax+1,neqn)
#endif
      double precision, allocatable:: psiCoarse(:,:,:,:)
      double precision, allocatable:: psiTCoarse(:,:,:,:)
      double precision, allocatable:: resCorrCoarse(:,:,:,:)
      double precision, allocatable:: resg(:,:,:,:)
      double precision, allocatable:: psig(:,:,:,:), psiTg(:,:,:,:)
      double precision:: dx(3)
      double precision:: dxc(3)
      integer:: maxPreSmoothIterations
      integer:: maxPostSmoothIterations
      integer:: gammaK
      integer:: iterGamma
      integer:: imaxc,jmaxc,kmaxc
      maxPreSmoothIterations=10
      maxPostSmoothIterations=10
      gammaK=1
      
      
      if(level.eq.lMax) then
         if(level.eq.0) bcHFlag=0
         call BottomSolve3D(psiT,psi,res,imax,jmax,kmax,neqn,level,dx)
c
      else
         call Smooth3D(psiT,psi,res,maxPreSmoothIterations,
     &        imax,jmax,kmax,neqn,level,dx)
         call Residual3D(psi,res,resCorr,imax,jmax,kmax,neqn,level,dx)
         imaxg=(imax)
#ifndef TWO_D
         jmaxg=(jmax)
#else
         jmaxg=1
#endif

         kmaxg=(kmax)
         imaxc=imaxg/2
#ifndef TWO_D
         jmaxc=jmaxg/2
#else
         jmaxc=1
#endif
         kmaxc=kmaxg/2
c
#ifndef TWO_D
         allocate(psig(-2:imaxg+3,-2:jmaxg+3,-2:kmaxg+3,neqn))
         allocate(psiTg(-2:imaxg+3,-2:jmaxg+3,-2:kmaxg+3,neqn))
         allocate(resg(imaxg+1,jmaxg+1,kmaxg+1,neqn))
         allocate(resCorrCoarse(imaxc+1,jmaxc+1,kmaxc+1,neqn))
         allocate(psiCoarse(-2:imaxc+3,-2:jmaxc+3,-2:kmaxc+3,neqn))
         allocate(psiTCoarse(-2:imaxc+3,-2:jmaxc+3,-2:kmaxc+3,neqn))
#else
         allocate(psig(-2:imaxg+3,jmaxg,-2:kmaxg+3,neqn))
         allocate(psiTg(-2:imaxg+3,jmaxg,-2:kmaxg+3,neqn))
         allocate(resg(imaxg+1,jmaxg,kmaxg+1,neqn))
         allocate(resCorrCoarse(imaxc+1,jmaxc,kmaxc+1,neqn))
         allocate(psiCoarse(-2:imaxc+3,jmaxc,-2:kmaxc+3,neqn))
         allocate(psiTCoarse(-2:imaxc+3,jmaxc,-2:kmaxc+3,neqn))
#endif
c
         resg=resCorr
         psig=psi
         psiTg=psiT
         call Restrict3D(resg,resCorrCoarse,
     &           imaxg,jmaxg,kmaxg,neqn)
         psiTCoarse=0.D0
         psiCoarse=0.D0
         bcHFlag=1
         dxc=2.D0*dx
c
         do iterGamma=1,gammaK,1
               write (*        ,*) " Here iterGamma=",iterGamma,
     &              " gammaK=",gammaK
               call MGSolve3D(psiCoarse,psiTCoarse,resCorrCoarse,
     &              imaxc,jmaxc,kmaxc,neqn,
     &              level+1,dxc)
               psiTCoarse=psiCoarse
         enddo
         resCorr=0.D0
         call Prolong3D(resg,imaxg,jmaxg,kmaxg,neqn, psiCoarse)
c
            resCorr=resg
            psi=psig
            psiT=psiTg
c
c     Perhaps update component by component
#ifndef TWO_D
         psi(1:imax+1,1:jmax+1,1:kmax+1,:)=
     &           psi(1:imax+1,1:jmax+1,1:kmax+1,:)+
     &        resCorr(1:imax+1,1:jmax+1,1:kmax+1,:)
#else
         psi(1:imax+1,1:jmax,1:kmax+1,:)=
     &           psi(1:imax+1,1:jmax,1:kmax+1,:)+
     &        resCorr(1:imax+1,1:jmax,1:kmax+1,:)
#endif
         bcHFlag=1
         psiT=psi
c
         if(level.eq.0) bcHFlag=0
         call Smooth3D(psi,psi,res,maxPostSmoothIterations,
     &        imax,jmax,kmax,neqn,level,dx)
c
         deallocate(psig)
         deallocate(psiTg)
         deallocate(resg)
         deallocate(resCorrCoarse)
         deallocate(psiCoarse)
         deallocate(psiTCoarse)
      endif
c
      return
      end subroutine
c-----------------------------------------------------------------------
       subroutine DetermineMaxLevel3D(lMax,nx,ny,nz)
c-----------------------------------------------------------------
c      Input: Domain size nx x ny
c      Output: Max no. of levels possible if each level is coarsened
c              by a factor of 2 from the previous finer level.
       implicit none
       integer:: lMax, nx,ny,nz
       integer:: m,n,p
       integer:: i
c
       m=nx
       n=ny
       p=nz
       lMax=3
       do i=1,32,1
          if(mod(m,2).ne.0. or. mod(n,2).ne.0.or.mod(p,2).ne.0) then
             return
          else
             lmax=lmax+1
             m=m/2
             n=n/2
             p=p/2
          endif
       enddo
       return
       end subroutine
c-----------------------------------------------------------------------
      subroutine Smooth3D(psiT,psi,res,maxIterations,
     &     imax,jmax,kmax,neqn,
     &     level,dx)
c-----------------------------------------------------------------------
c     Input: psiT - psi_tilde
c     res  - residual
c     maxIterations - max no. of smoothing iterations
c     imax,jmax: mesh size
c     level - multi-grid level (not used here)
c     dx - mesh spacing
c     Implicit input: xChangeFlag  =1,0. Do (not) Exchange ghost 
c     information at this level if this is 1 (0).
c     bchflag = 0,1. Use (do not use)  homogeneous 
c     boundary conditions if this is  1 (0)
c     Output: psi - after smoothing of psiT
c     Description: Uses Gauss-Siedel red-black ordering
c-----------------------------------------------------------------------
      use mesh_uparms
      use mesh_common
      use MGParamsv
       implicit none
       integer:: imax, jmax,kmax,neqn,level,maxIterations
#ifndef TWO_D
      double precision:: psi(-2:imax+3,-2:jmax+3,-2:kmax+3,neqn)
      double precision:: psiT(-2:imax+3,-2:jmax+3,-2:kmax+3,neqn)
      double precision:: res(imax+1,jmax+1,kmax+1,neqn)
#else
      double precision:: psi(-2:imax+3,jmax,-2:kmax+3,neqn)
      double precision:: psiT(-2:imax+3,jmax,-2:kmax+3,neqn)
      double precision:: res(imax+1,jmax,kmax+1,neqn)
#endif

c     
c      integer:: i,j,k,iter
      double precision:: dx(3)
c     
      call GaussSeidel(psiT,psi,res,maxIterations,
     &        imax,jmax,kmax,neqn,level,dx)
      return
c
      end subroutine
c
c-----------------------------------------------------------------------
      subroutine BottomSolve3D(psiT,psi,res,
     &        imax,jmax,kmax,neqn,level,dx)
c-----------------------------------------------------------------------
c     Description: Used when mesh cannot be coarsened anymore. 
c                  Still uses Gauss-Siedel Red-Black for
c                  100 iterations. 
c     Issues: 100 is hard -coded but seems to work for the reconnection
c             problem. A better bottom solver (e.g. biconjugate gradient)
c             would be desirable.
c     Input: psiT - psi_tilde
c            res - residual
c            imax,jmax: local mesh size
c            level - multi-grid level
c            dx - local mesh spacing
c     Output: psi
c-----------------------------------------------------------------------
       implicit none
       integer:: imax,jmax,kmax,neqn,level
#ifndef TWO_D
      double precision:: psi(-2:imax+3,-2:jmax+3,-2:kmax+3,neqn)
      double precision:: psiT(-2:imax+3,-2:jmax+3,-2:kmax+3,neqn)
      double precision:: res(imax+1,jmax+1,kmax+1,neqn)
#else
      double precision:: psi(-2:imax+3,jmax,-2:kmax+3,neqn)
      double precision:: psiT(-2:imax+3,jmax,-2:kmax+3,neqn)
      double precision:: res(imax+1,jmax,kmax+1,neqn)
#endif

      double precision:: dx(3)
c      integer:: i,j,k
c
      call GaussSeidel(psiT,psi,res,1000,
     &        imax,jmax,kmax,neqn,level,dx)
      return
      end subroutine

c-----------------------------------------------------------------------
      Subroutine Residual3D(psi,res,resCorr,imax,jmax,kmax,neqn,
     &     level,dx)
c-----------------------------------------------------------------------
c     Description: Calculate the residual Residual=L(phi)- RHS
c     Input: psi 
c            res - rhs 
c            imax,jmax: local mesh size
c            dx - local mesh spacing
c     Output: resCorr  evualated as resCorr=L(psi)-res
c-----------------------------------------------------------------------
      use mesh_common
      implicit none
      integer:: imax,jmax,kmax,neqn,level
#ifndef TWO_D
      double precision:: psi(-2:imax+3,-2:jmax+3,-2:kmax+3,neqn)
      double precision:: resCorr(imax+1,jmax+1,kmax+1,neqn)
      double precision:: res(imax+1,jmax+1,kmax+1,neqn)
#else
      double precision:: psi(-2:imax+3,jmax,-2:kmax+3,neqn)
      double precision:: resCorr(imax+1,jmax,kmax+1,neqn)
      double precision:: res(imax+1,jmax,kmax+1,neqn)
#endif

      double precision:: dx(3)
c
      integer:: i,j,k
#ifndef TWO_D
      double precision:: resTmp(-2:imax+3,-2:jmax+3,-2:kmax+3,neqn)
#else
      double precision:: resTmp(-2:imax+3,jmax,-2:kmax+3,neqn)
#endif
c     
c
c      write(6,*) 'RES',imax,jmax,kmax,neqn,dx
      resCorr=0.D0
      call ApplyOperatorVel(psi,restmp,imax,jmax,kmax,neqn,level,dx)
      do k=1,kmax,1
      do j=1,jmax,1
         do i=1,imax+1,1
            resCorr(i,j,k,1)=res(i,j,k,1)
     &           -resTmp(i,j,k,1)
         enddo
      enddo
      enddo
      if(iprocx.eq.1) then
         resCorr(1,:,:,1)=0.D0
      endif
#ifndef TWO_D
      do k=1,kmax,1
      do j=1,jmax+1,1
         do i=1,imax,1
            resCorr(i,j,k,2)=res(i,j,k,2)
     &           -resTmp(i,j,k,2)
         enddo
      enddo
      enddo
#else
      resCorr(:,:,:,2)=0.D0
#endif
      do k=1,kmax+1,1
      do j=1,jmax,1
         do i=1,imax,1
            resCorr(i,j,k,3)=res(i,j,k,3)
     &           -resTmp(i,j,k,3)
         enddo
      enddo
      enddo
      if(iprocz.eq.1) then
         resCorr(:,:,1,3)=0.d0
      endif
c
c      write(6,*) 'MAXVAL RESCORR=',
c     &     maxval(dabs(resCorr(1:imax+1,1:jmax,1:kmax,1)))
      return
      end subroutine
c-----------------------------------------------------------------------
      Subroutine Restrict3D(psi,psiCoarse,imax,jmax,kmax,neqn)
c-----------------------------------------------------------------------
c     Description: Restrict the solution onto the next coarser level
c     Input: psi - solution at current level
c            imax,jmax: mesh size at the current level
c     Output: phiCoarse: solution on the next coarser level
c-----------------------------------------------------------------------
       implicit none
      integer:: imax,jmax,kmax,neqn
#ifndef TWO_D
      double precision:: psi(imax+1,jmax+1,kmax+1,neqn)
      double precision:: psiCoarse(imax/2+1,jmax/2+1,kmax/2+1,neqn)
#else
      double precision:: psi(imax+1,jmax,kmax+1,neqn)
      double precision:: psiCoarse(imax/2+1,jmax,kmax/2+1,neqn)
#endif
c
      integer:: i,j,k
      integer:: ii,jj,kk
c
      psiCoarse=0.D0
#ifndef TWO_D
      do k=1,kmax/2,1
         kk=(k-1)*2+1
         do j=1,jmax/2,1
            jj=(j-1)*2+1
            do i=1,imax/2+1,1
               ii=i*2-1
               psiCoarse(i,j,k,1)=0.25D0*(
     &              psi(ii,jj,kk,1)+psi(ii,jj+1,kk,1)
     &              +psi(ii,jj+1,kk+1,1)+psi(ii,jj,kk+1,1))
            enddo
         enddo
      enddo
#else
      j=1
      jj=1
      do k=1,kmax/2,1
         kk=(k-1)*2+1
         do i=1,imax/2+1,1
            ii=i*2-1
            psiCoarse(i,j,k,1)=0.5D0*(
     &           psi(ii,jj,kk,1)+psi(ii,jj,kk+1,1))
         enddo
      enddo
#endif
c
#ifndef TWO_D
      do k=1,kmax/2,1
         kk=(k-1)*2+1
         do j=1,jmax/2+1,1
            jj=j*2-1
            do i=1,imax/2,1
               ii=(i-1)*2+1
               psiCoarse(i,j,k,2)=0.25D0*(
     &              psi(ii,jj,kk,2)+psi(ii+1,jj,kk,2)
     &              +psi(ii+1,jj,kk+1,2)+psi(ii,jj,kk+1,2))
            enddo
         enddo
      enddo
#endif

#ifndef TWO_D
      do k=1,kmax/2+1,1
         kk=k*2-1
         do j=1,jmax/2,1
            jj=(j-1)*2+1
            do i=1,imax/2,1
               ii=(i-1)*2+1
               psiCoarse(i,j,k,3)=0.25D0*(
     &              psi(ii,jj,kk,3)+psi(ii,jj+1,kk,3)
     &              +psi(ii+1,jj+1,kk,3)+psi(ii+1,jj,kk,3))
            enddo
         enddo
      enddo
#else
      j=1
      jj=1
      do k=1,kmax/2+1,1
         kk=k*2-1
         do i=1,imax/2,1
            ii=(i-1)*2+1
            psiCoarse(i,j,k,3)=0.5D0*(
     &           psi(ii,jj,kk,3)+psi(ii+1,jj,kk,3))
         enddo
      enddo
#endif
      return
      end subroutine
c-----------------------------------------------------------------------
      subroutine  Prolong3D(psi,imax,jmax,kmax, neqn,psiCoarse)
c-----------------------------------------------------------------------
c     Description: Prolong the solution onto the next finer level
c     Input: psiCoarse - solution at current level
c            imax,jmax: mesh size at the next finer level
c     Output: phi: solution prolonged on the next finer level
c     Issues:  Is this second order accurate? Do we care, because the 
c              entire MG solver is converging well?
c-----------------------------------------------------------------------
       implicit none
      integer:: imax,jmax,kmax,neqn
#ifndef TWO_D
      double precision:: psi(imax+1,jmax+1,kmax+1,neqn)
      double precision::
     &     psiCoarse(-2:imax/2+3,-2:jmax/2+3,-2:kmax/2+3,neqn)
#else
      double precision:: psi(imax+1,jmax,kmax+1,neqn)
      double precision::
     &     psiCoarse(-2:imax/2+3,jmax,-2:kmax/2+3,neqn)
#endif
      double precision::tmp
      integer:: i,j,k,ip,jp,kp
      integer:: ii,jj,kk
c
#ifndef TWO_D
      do k=1,kmax/2,1
         kk=(k-1)*2+1
      do j=1,jmax/2,1
         jj=(j-1)*2+1
         do ii=1,imax+1,1
            i=(ii+1)/2
            ip=(ii+2)/2
            tmp=0.5D0*(psiCoarse(i,j,k,1)
     &           +psiCoarse(ip,j,k,1))
            psi(ii,jj,kk,1)=tmp
            psi(ii,jj+1,kk,1)=tmp
            psi(ii,jj,kk+1,1)=tmp
            psi(ii,jj+1,kk+1,1)=tmp
         enddo
      enddo
      enddo
#else
      j=1
      jj=1
      do k=1,kmax/2,1
         kk=(k-1)*2+1
         do ii=1,imax+1,1
            i=(ii+1)/2
            ip=(ii+2)/2
            tmp=0.5D0*(psiCoarse(i,j,k,1)
     &           +psiCoarse(ip,j,k,1))
            psi(ii,jj,kk,1)=tmp
            psi(ii,jj,kk+1,1)=tmp
         enddo
      enddo
#endif
c
#ifndef TWO_D
      do k=1,kmax/2,1
         kk=(k-1)*2+1
      do jj=1,jmax+1,1
            j=(jj+1)/2
            jp=(jj+2)/2
         do i=1,imax/2,1
            ii=(i-1)*2+1
            tmp=0.5D0*(psiCoarse(i,j,k,2)
     &           +psiCoarse(i,jp,k,2))
            psi(ii,jj,kk,2)=tmp
            psi(ii+1,jj,kk,2)=tmp
            psi(ii,jj,kk+1,2)=tmp
            psi(ii+1,jj,kk+1,2)=tmp
         enddo
      enddo
      enddo
#else
      psi(:,:,:,2)=0.D0
#endif
c
#ifndef TWO_D
      do kk=1,kmax+1,1
         k=(kk+1)/2
         kp=(kk+2)/2
      do j=1,jmax/2,1
         jj=(j-1)*2+1
         do i=1,imax/2,1
            ii=(i-1)*2+1
            tmp=0.5D0*(psiCoarse(i,j,k,3)
     &           +psiCoarse(i,j,kp,3))
            psi(ii,jj,kk,3)=tmp
            psi(ii,jj+1,kk,3)=tmp
            psi(ii+1,jj+1,kk,3)=tmp
            psi(ii+1,jj,kk,3)=tmp
         enddo
      enddo
      enddo
#else
      j=1
      jj=1
      do kk=1,kmax+1,1
         k=(kk+1)/2
         kp=(kk+2)/2
         do i=1,imax/2,1
            ii=(i-1)*2+1
            tmp=0.5D0*(psiCoarse(i,j,k,3)
     &           +psiCoarse(i,j,kp,3))
            psi(ii,jj,kk,3)=tmp
            psi(ii+1,jj,kk,3)=tmp
         enddo
      enddo
#endif
c
      return
      end subroutine

c-----------------------------------------------------------------------
      Subroutine GaussSeidel(psiT,psi,res,maxIter,imax,jmax,kmax,neqn,
     &     level,dx)
c-----------------------------------------------------------------------
c     Description: Calculate the residual Residual=L(phi)- RHS
c     Input: psiT
c     Output: psi
c     res - rhs 
c     imax,jmax,kmax: local mesh size
c     dx - local mesh spacing
c     Output: resCorr  evaluated as resCorr=L(psi)-res
c-----------------------------------------------------------------------
      use mesh_common
      use mgparamsv
      use VelParameters
      use iounits
      implicit none
      integer:: imax,jmax,kmax, neqn,level
#ifndef TWO_D
      double precision:: psi(-2:imax+3,-2:jmax+3,-2:kmax+3,neqn)
      double precision:: psiT(-2:imax+3,-2:jmax+3,-2:kmax+3,neqn)
      double precision:: res(imax+1,jmax+1,kmax+1,neqn)
      double precision:: resx(imax+1,jmax+1,kmax+1,neqn)
#else
      double precision:: psi(-2:imax+3,jmax,-2:kmax+3,neqn)
      double precision:: psiT(-2:imax+3,jmax,-2:kmax+3,neqn)
      double precision:: res(imax+1,jmax,kmax+1,neqn)
      double precision:: resx(imax+1,jmax,kmax+1,neqn)
#endif
      double precision:: resMax
c     
      double precision:: dx(3)
      double precision:: dxi,dyi,dzi
c     
      integer:: i,j,k,ilo, klo
c     
      double precision:: fac1 !,fac2
      double precision:: tolerance
      integer:: iter, MaxIter
c     
c     
      tolerance=1.D-10
      fac1=ldata(level)%nu
      dxi=ldata(level)%delx**2
      dyi=ldata(level)%dely**2
      dzi=ldata(level)%delz**2
c      fac2=1.D0/(1.D0+(2.D0*dxi+2.D0*dyi+2.D0*dzi)*fac1)
      Call ExchangePsi3D(psiT,imax,jmax,kmax,neqn,xChangeFlag)
      psi=psiT
      Call ExchangePsi3D(psi,imax,jmax,kmax,neqn,xChangeFlag)
c     
      iter=1
      resMax=1.D16
      do while(iter.le.MaxIter.and.resMax.gt.tolerance)
         if (bcHFlag.eq.0) then
            call BC3D(psi,dx,imax,jmax,kmax,xChangeFlag)
         else
            call BCHomogeneous3D(psi,imax,jmax,kmax,xChangeFlag)
         endif
c
         ilo=1
         klo=1
         if(iprocx.eq.1) ilo=2
         if(iprocz.eq.1) klo=2
         do k=1,kmax,1
         do j=1,jmax,1
c            do i=1,imax+1,1
            do i=ilo,imax+1,1
#ifndef TWO_D
               psi(i,j,k,1)=(res(i,j,k,1)+
     &              ldata(0)%nu*(
     &              (cc*(psi(i+2,j,k,1)+psi(i-2,j,k,1))+
     &              aa*(psi(i+1,j,k,1)+psi(i-1,j,k,1)))/dx(1)**2
     &              +(cc*(psi(i,j+2,k,1)+psi(i,j-2,k,1))+
     &              aa*(psi(i,j+1,k,1)+psi(i,j-1,k,1)))/dx(2)**2
     &              +(cc*(psi(i,j,k+2,1)+psi(i,j,k-2,1))
     &              +(aa*(psi(i,j,k+1,1)+psi(i,j,k-1,1))))/dx(3)**2))/
     &            (1.D0-bb*(1.D0/dx(1)**2+1.D0/dx(2)**2+1.D0/dx(3)**2)*
     &             ldata(0)%nu)
#else
               psi(i,j,k,1)=(res(i,j,k,1)+
     &              ldata(0)%nu*(
     &              (cc*(psi(i+2,j,k,1)+psi(i-2,j,k,1))+
     &              aa*(psi(i+1,j,k,1)+psi(i-1,j,k,1)))/dx(1)**2
     &              +(cc*(psi(i,j,k+2,1)+psi(i,j,k-2,1))
     &              +(aa*(psi(i,j,k+1,1)+psi(i,j,k-1,1))))/dx(3)**2))/
     &            (1.D0-bb*(1.D0/dx(1)**2+1.D0/dx(3)**2)*
     &             ldata(0)%nu)
#endif
            enddo
         enddo
         enddo
c
#ifndef TWO_D
         do k=1,kmax,1
         do j=1,jmax+1,1
            do i=1,imax,1
               psi(i,j,k,2)=(res(i,j,k,2)+
     &              ldata(0)%nu*(
     &              (cc*(psi(i+2,j,k,2)+psi(i-2,j,k,2))+
     &              aa*(psi(i+1,j,k,2)+psi(i-1,j,k,2)))/dx(1)**2
     &              +(cc*(psi(i,j+2,k,2)+psi(i,j-2,k,2))+
     &              aa*(psi(i,j+1,k,2)+psi(i,j-1,k,2)))/dx(2)**2
     &              +(cc*(psi(i,j,k+2,2)+psi(i,j,k-2,2))
     &              +(aa*(psi(i,j,k+1,2)+psi(i,j,k-1,2))))/dx(3)**2))/
     &            (1.D0-bb*(1.D0/dx(1)**2+1.D0/dx(2)**2+1.D0/dx(3)**2)*
     &             ldata(0)%nu)
            enddo
         enddo
         enddo
#else
         psi(:,:,:,2)=0.D0
#endif
c
         do k=klo,kmax+1,1
         do j=1,jmax,1
            do i=1,imax,1
#ifndef TWO_D
               psi(i,j,k,3)=(res(i,j,k,3)+
     &              ldata(0)%nu*(
     &              (cc*(psi(i+2,j,k,3)+psi(i-2,j,k,3))+
     &              aa*(psi(i+1,j,k,3)+psi(i-1,j,k,3)))/dx(1)**2
     &              +(cc*(psi(i,j+2,k,3)+psi(i,j-2,k,3))+
     &              aa*(psi(i,j+1,k,3)+psi(i,j-1,k,3)))/dx(2)**2
     &              +(cc*(psi(i,j,k+2,3)+psi(i,j,k-2,3))
     &              +(aa*(psi(i,j,k+1,3)+psi(i,j,k-1,3))))/dx(3)**2))/
     &            (1.D0-bb*(1.D0/dx(1)**2+1.D0/dx(2)**2+1.D0/dx(3)**2)*
     &             ldata(0)%nu)
#else
               psi(i,j,k,3)=(res(i,j,k,3)+
     &              ldata(0)%nu*(
     &              (cc*(psi(i+2,j,k,3)+psi(i-2,j,k,3))+
     &              aa*(psi(i+1,j,k,3)+psi(i-1,j,k,3)))/dx(1)**2
     &              +(cc*(psi(i,j,k+2,3)+psi(i,j,k-2,3))
     &              +(aa*(psi(i,j,k+1,3)+psi(i,j,k-1,3))))/dx(3)**2))/
     &            (1.D0-bb*(1.D0/dx(1)**2+1.D0/dx(3)**2)*
     &             ldata(0)%nu)
#endif
            enddo
         enddo
         enddo
c
         Call ExchangePsi3D(psi,imax,jmax,kmax,neqn,xChangeFlag)
         call Residual3D(psi,res,resx,imax,jmax,kmax,neqn,level,dx)
#ifndef TWO_D
         call MaxNorm3D(resx,imax+1,jmax+1,kmax+1,neqn,resMax)
#else
         call MaxNorm3D(resx,imax+1,jmax,kmax+1,neqn,resMax)
#endif
c
c     
         call Residual3D(psi,res,resx,imax,jmax,kmax,neqn,level,dx)
#ifndef TWO_D
         call MaxNorm3D(resx,imax+1,jmax+1,kmax+1,neqn,resMax)
#else
         call MaxNorm3D(resx,imax+1,jmax,kmax+1,neqn,resMax)
#endif

         iter=iter+1
c         write(6,*) 'Level',level,'Max Norm 3D Residual=',iter,resMax
         write(ihis,*)'Level',level,'Max Norm 3D Residual=',iter,resMax
      enddo
c      stop
      if (bcHFlag.eq.0) then
         call BC3D(psi,dx,imax,jmax,kmax,xChangeFlag)
      else
         call BCHomogeneous3D(psi,imax,jmax,kmax,xChangeFlag)
      endif
      call Residual3D(psi,res,resx,imax,jmax,kmax,neqn,level,dx)
#ifndef TWO_D
         call MaxNorm3D(resx,imax+1,jmax+1,kmax+1,neqn,resMax)
#else
         call MaxNorm3D(resx,imax+1,jmax,kmax+1,neqn,resMax)
#endif
c      write(6,*) 'Level',level,'Max Norm 3D Residual=',iter,resMax
c     
      return
      end subroutine
c-----------------------------------------------------------------------
        subroutine XBC(psi,imax,jmax,kmax,ncomp)
        use mesh_parms
        use mesh_common
        use InflowVelBC
        use outflowBC
#ifdef  LES
        use virtualwallBC
#endif
        implicit none
        integer:: imax,jmax,kmax,ncomp
#ifndef TWO_D
        double precision:: psi(-2:imax+3,-2:jmax+3,-2:kmax+3,ncomp)
#else
        double precision:: psi(-2:imax+3,jmax,-2:kmax+3,ncomp)
#endif
        
        integer i,j,k,l
        integer:: ng
c       
c     Check if imax is the same as nxlocal
        if(imax.ne.nxlocal.or.jmax.ne.nylocal.or.kmax.ne.nzlocal) then
           write(6,*) 'XBC: Incorrect Sizes - should abort'
           call Abortend
        endif
c
        ng=3
        if (iprocx .eq. 1) then
           i=1
           do k=-2,kmax+3,1
#ifndef TWO_D
              do j=-2,jmax+3,1
                 psi(i,j,k,1)=Uin(1,j,k,1)
                 psi(i-1,j,k,1)=Uin(2,j,k,1)
                 psi(i-2,j,k,1)=Uin(3,j,k,1)
c                 psi(i-1,j,k,1)=2.D0*Uin(1,j,k,1)-psi(i+1,j,k,1)
c                 psi(i-2,j,k,1)=2.D0*Uin(1,j,k,1)-psi(i+2,j,k,1)
              enddo
#else
              j=1
              psi(i,j,k,1)=Uin(1,j,k,1)
              psi(i-1,j,k,1)=2.D0*Uin(1,j,k,1)-psi(i+1,j,k,1)
              psi(i-2,j,k,1)=2.D0*Uin(1,j,k,1)-psi(i+2,j,k,1)
#endif
           enddo
           i=0
           do k=-2,kmax+3,1
#ifndef TWO_D
              do j=-2,jmax+3,1
                 do l=0,ng-1,1
c                 psi(i-l,j,k,2:3)=2.d0*Uin(1,j,k,2:3)-psi(i+l+1,j,k,2:3)
c                 psi(i-l,j,k,2:3)= psi(i+l+1,j,k,2:3)
                 psi(i-l,j,k,2:3)= Uin(2+l,j,k,2:3)
                 enddo
              enddo
#else
              j=1
              do l=0,ng-1,1
                 psi(i-l,j,k,2:3)=2.d0*Uin(1,j,k,2:3)-psi(i+l+1,j,k,2:3)
              enddo
#endif

           enddo
        endif
c----------------------------------
#ifdef CODEB
        ng=3
        if (iprocx .eq. 1) then
           i=1
           do k=-2,kmax+3,1
              do j=-2,jmax+3,1
                 psi(i,j,k,1)  = Uin(1,j,k,1)
                 psi(i-1,j,k,1)= Uin(2,j,k,1)
                 psi(i-2,j,k,1)= Uin(3,j,k,1)
              enddo
           enddo
           i=0
           do k=-2,kmax+3,1
              do j=-2,jmax+3,1
                 do l=0,ng-1,1
                 psi(i-l,j,k,2:3)= Uin(2+l,j,k,2:3)
                 enddo
              enddo
           enddo
        endif
#endif
c-----
        if (iprocx .eq. xprocs) then
           i=imax+1
           do k=-2,kmax+3,1
#ifndef TWO_D
              do j=-2,jmax+3,1
#ifndef OUTFBC
                    psi(i+1,j,k,1)=psi(i-1,j,k,1)
                    psi(i+2,j,k,1)=psi(i-2,j,k,1)
#else
                    psi(i+1,j,k,1)=bc_outflowu(1,j,k,1)
                    psi(i+2,j,k,1)=bc_outflowu(2,j,k,1)
#endif
                 enddo
#else
                 j=1
#ifndef OUTFBC
                 psi(i+1,j,k,1)=psi(i-1,j,k,1)
                 psi(i+2,j,k,1)=psi(i-2,j,k,1)
#else
                 psi(i+1,j,k,1)=bc_outflowu(1,j,k,1)
                 psi(i+2,j,k,1)=bc_outflowu(2,j,k,1)
#endif
#endif
              enddo
           do k=-2,kmax+3,1
#ifndef TWO_D
              do j=-2,jmax+3,1
                 do l=0,ng-1,1
#ifndef OUTFBC
                 psi(i+l,j,k,2:3)=psi(i-l-1,j,k,2:3)
#else
                 psi(i+l,j,k,2:3)=bc_outflowu(l+1,j,k,2:3)
#endif
                 enddo
                 enddo
#else
                 j=1
                 do l=0,ng-1,1
#ifndef OUTFBC
                 psi(i+l,j,k,2:3)=psi(i-l-1,j,k,2:3)
#else
                 psi(i+l,j,k,2:3)=bc_outflowu(l+1,j,k,2:3)           
#endif
                 enddo
#endif

              enddo
           endif
c       
        return
        end subroutine
c
c-----------------------------------------------------------------------
        subroutine XBCH(psi,imax,jmax,kmax,ncomp)
        use mesh_parms
        use mesh_common
#ifdef  LES
        use virtualwallBC
#endif
        implicit none
        integer:: imax,jmax,kmax,ncomp
#ifndef TWO_D
        double precision:: psi(-2:imax+3,-2:jmax+3,-2:kmax+3,ncomp)
#else
        double precision:: psi(-2:imax+3,jmax,-2:kmax+3,ncomp)
#endif
        integer i,j,k,l
        integer:: ng
c       
        ng=3
c       
        if (iprocx .eq. 1) then
           i=1
           do k=-2,kmax+3,1
#ifndef TWO_D
              do j=-2,jmax+3,1
                 psi(i,j,k,1)=0.D0
                 psi(i-1,j,k,1)=0.D0
                 psi(i-2,j,k,1)=0.D0
c                 psi(i-1,j,k,1)= -psi(i+1,j,k,1)
c                 psi(i-2,j,k,1)= -psi(i+2,j,k,1)
              enddo
#else
              j=1
              psi(i,j,k,1)=0.D0
              psi(i-1,j,k,1)= -psi(i+1,j,k,1)
              psi(i-2,j,k,1)= -psi(i+2,j,k,1)
#endif
           enddo
           i=0
           do k=-2,kmax+3,1
#ifndef TWO_D
              do j=-2,jmax+3,1
                 do l=0,ng-1,1
c                 psi(i-l,j,k,2:3)= -psi(i+l+1,j,k,2:3)
                 psi(i-l,j,k,2:3)= 0.D0
                 enddo
              enddo
#else
              j=1
              do l=0,ng-1,1
                 psi(i-l,j,k,2:3)= -psi(i+l+1,j,k,2:3)
              enddo
#endif

           enddo
        endif
c
#ifdef CODEB
        if (iprocx .eq. 1) then
           i=1
           do k=-2,kmax+3,1
              do j=-2,jmax+3,1
                 psi(i,j,k,1)  = 0.D0
                 psi(i-1,j,k,1)= 0.D0
                 psi(i-2,j,k,1)= 0.D0
              enddo
           enddo
           i=0
           do k=-2,kmax+3,1
              do j=-2,jmax+3,1
                 do l=0,ng-1,1
                 psi(i-l,j,k,2:3)= 0.D0
                 enddo
              enddo
           enddo
        endif
#endif
c       
        if (iprocx .eq. xprocs) then
           i=imax+1
           do k=-2,kmax+3,1
#ifndef TWO_D
              do j=-2,jmax+3,1
#ifndef OUTFBC
                    psi(i+1,j,k,1)=psi(i-1,j,k,1)
                    psi(i+2,j,k,1)=psi(i-2,j,k,1)
#else
                    psi(i+1,j,k,1)=0.d0
                    psi(i+2,j,k,1)=0.d0
#endif
                 enddo
#else
                 j=1
#ifndef OUTFBC
                 psi(i+1,j,k,1)=psi(i-1,j,k,1)
                 psi(i+2,j,k,1)=psi(i-2,j,k,1)
#else
                 psi(i+1,j,k,1)=0.d0
                 psi(i+2,j,k,1)=0.d0     
#endif
#endif
              enddo
           do k=-2,kmax+3,1
#ifndef TWO_D
              do j=-2,jmax+3,1
                 do l=0,ng-1,1
c
#ifndef OUTFBC
                 psi(i+l,j,k,2:3)=psi(i-l-1,j,k,2:3)
#else
                 psi(i+l,j,k,2:3)=0.d0
#endif
c
                 enddo
                 enddo
#else
                 j=1
                 do l=0,ng-1,1
#ifndef OUTFBC
                 psi(i+l,j,k,2:3)=psi(i-l-1,j,k,2:3)
#else
                 psi(i+l,j,k,2:3)= 0.d0
#endif
                 enddo
#endif

              enddo
           endif
c
        return
        end subroutine
c
c-----------------------------------------------------------------------
c       YBC periodic
        subroutine YBCPeriodic(psi,imax,jmax,kmax,ncomp)
        use mesh_parms
        use mesh_common
        implicit none
        integer:: imax,jmax,kmax,ncomp
        double precision:: psi(-2:imax+3,-2:jmax+3,-2:kmax+3,ncomp)
        integer i,j,k,l
        integer:: ng
c       
#ifndef TWO_D
        ng=3
c       
c     we rely on this for periodic bc if yprocs = 1 otherwise
c     the exchange routine will take care of it.
        if (yprocs .eq. 1) then
           j=0
           do k=-2,kmax+3,1
              do i=-2,imax+3,1
                 do l=0,ng-1,1
                    psi(i,j-l,k,1)=psi(i,jmax-l,k,1)
                    psi(i,j-l,k,3)=psi(i,jmax-l,k,3)
                 enddo
              enddo
           enddo
           j=1
           do k=-2,kmax+3,1
              do i=-2,imax+3,1
                 do l=0,ng-1,1
                    psi(i,j-l,k,2)=psi(i,jmax+1-l,k,2)
                 enddo
              enddo
           enddo
           j=jmax+1
           do k=-2,kmax+3,1
              do i=-2,imax+3,1
                 do l=0,ng-1,1
                    psi(i,j+l,k,1)=psi(i,l+1,k,1)
                    psi(i,j+l,k,3)=psi(i,l+1,k,3)
                 enddo
              enddo
           enddo
           do k=-2,kmax+3,1
              do i=-2,imax+3,1
                 do l=0,ng-1,1
                    psi(i,j+l,k,2)=psi(i,l+1,k,2)
                 enddo
              enddo
           enddo
        endif
c       
#endif
        return
        end subroutine
c-----------------------------------------------------------------------
c       ZBC  only for the finest mesh
        subroutine ZBC(psi,imax,jmax,kmax,ncomp)
        use mesh_parms
        use mesh_common
#ifdef  LES
        use virtualwallBC
#endif
        implicit none
        integer:: imax,jmax,kmax,ncomp
        double precision:: vt
#ifndef TWO_D
        double precision:: psi(-2:imax+3,-2:jmax+3,-2:kmax+3,ncomp)
        double precision:: tmp(-2:imax+3,-2:jmax+3,ncomp)
#else
        double precision:: psi(-2:imax+3,jmax,-2:kmax+3,ncomp)
        double precision:: tmp(-2:imax+3,jmax,ncomp)
#endif

        integer i,j,k,l
        integer:: ng
        integer:: jlo,jhi
c       
        ng=3
c       
#ifndef TWO_D
        jlo=-2
        jhi=jmax+3
#else
        jlo=1
        jhi=1
#endif
c
#ifndef TWO_D
#ifdef  LES
        tmp(-2:imax+3,-2:jmax+3,1:3) =  !0.d0
     &   bc_uwall(-2:imax+3,-2:jmax+3,1:3)
#else
        tmp = 0.d0
#endif
#else
        tmp = 0.d0
#endif
c        write(6,*) 'ZBC'

        if (iprocz .eq. 1) then
           k=0
           do j=jlo,jhi,1
              do i=-2,imax+3,1
                 do l=0,ng-1,1
                 psi(i,j,k-l,1:2)=2.d0*tmp(i,j,1:2)-psi(i,j,k+l+1,1:2)
                 enddo
              enddo
           enddo
           k=1
           do j=jlo,jhi,1
              do i=-2,imax+3,1
                 psi(i,j,k,3)= tmp(i,j,3)
                 psi(i,j,k-1,3)=2.d0*tmp(i,j,3)-psi(i,j,k+1,3)
                 psi(i,j,k-2,3)=2.d0*tmp(i,j,3)-psi(i,j,k+2,3)
              enddo
           enddo
        endif
c       
        if (iprocz .eq. zprocs) then
           k=kmax+1
           do j=jlo,jhi,1
              do i=-2,imax+3,1
                 do l=0,ng-1,1
                 psi(i,j,k+l,1)=psi(i,j,k-l-1,1)
c                 psi(i,j,k+l,1)=  2.D0-psi(i,j,k-l-1,1)
                 psi(i,j,k+l,2)=psi(i,j,k-l-1,2)
                 enddo
              enddo
           enddo
           do j=jlo,jhi,1
              do i=-2,imax+3,1
c                 psi(i,j,k,3)= vt  !0.D0
c                 psi(i,j,k+1,3)=2.d0*vt - psi(i,j,k-1,3)
c                 psi(i,j,k+2,3)=2.d0*vt - psi(i,j,k-2,3) 
                 psi(i,j,k+1,3)= 2.d0*psi(i,j,k,3)- psi(i,j,k-1,3)
                 psi(i,j,k+2,3)= 2.d0*psi(i,j,k,3)- psi(i,j,k-2,3) 
              enddo
           enddo
        endif
c       
        return
        end subroutine
c
c
c-----------------------------------------------------------------------
c       ZBC 
        subroutine ZBCH(psi,imax,jmax,kmax,ncomp)
        use mesh_parms
        use mesh_common
        implicit none
        integer:: imax,jmax,kmax,ncomp
#ifndef TWO_D
        double precision:: psi(-2:imax+3,-2:jmax+3,-2:kmax+3,ncomp)
#else
        double precision:: psi(-2:imax+3,jmax,-2:kmax+3,ncomp)
#endif
        integer i,j,k,l
        integer:: ng
        integer:: jlo,jhi
c       
        ng=3
c       
#ifndef TWO_D
        jlo=-2
        jhi=jmax+3
#else
        jlo=1
        jhi=1
#endif
c       
c        write(6,*) 'ZBC'

        if (iprocz .eq. 1) then
           k=0
           do j=jlo,jhi,1
              do i=-2,imax+3,1
                 do l=0,ng-1,1
                 psi(i,j,k-l,1:2)=-psi(i,j,k+l+1,1:2)
                 enddo
              enddo
           enddo
           k=1
           do j=jlo,jhi,1
              do i=-2,imax+3,1
                 psi(i,j,k,3)=0.D0
                 psi(i,j,k-1,3)=-psi(i,j,k+1,3)
                 psi(i,j,k-2,3)=-psi(i,j,k+2,3)
              enddo
           enddo
        endif
c       
        if (iprocz .eq. zprocs) then
           k=kmax+1
           do j=jlo,jhi,1
              do i=-2,imax+3,1
                 do l=0,ng-1,1
c                 psi(i,j,k+l,1:2)=psi(i,j,k-l-1,1:2)
                 psi(i,j,k+l,1)=psi(i,j,k-l-1,1)
                 psi(i,j,k+l,2)=psi(i,j,k-l-1,2)
                 enddo
              enddo
           enddo
           do j=jlo,jhi,1
              do i=-2,imax+3,1
c                 psi(i,j,k,3)=0.D0
                 psi(i,j,k+1,3)=-psi(i,j,k-1,3)
                 psi(i,j,k+2,3)=-psi(i,j,k-2,3) 
              enddo
           enddo
        endif
c       
        return
        end subroutine
c
c
c-----------------------------------------------------------------------
       end module velocityfieldsolver
