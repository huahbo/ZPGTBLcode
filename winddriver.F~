c-----------------------------------------------------------------
c     Ravi Samtaney
c     Copyright 2011
c     King Abdullah University of Science and Technology
c     All Rights Reserved
c-----------------------------------------------------------------
c     $Log: winddriver.F,v $
c     Revision 1.6  2011/11/05 13:55:06  chengw
c     *** empty log message ***
c
c     Revision 1.5  2011/10/28 08:27:31  samtanr
c     Made Uin a 4D array.
c
c     Revision 1.3  2011/10/18 13:02:58  samtanr
c     Added code to handle inflow velocity to be function of y,z.
c
c     Revision 1.2  2011/10/03 08:18:29  samtanr
c     Intermediate checkin.
c
c     Revision 1.1  2011/07/25 11:32:01  samtanr
c     Original source.
c
c     Wind code: Incompressible Navier-Stokes LES
c
c-----------------------------------------------------------------
c
       subroutine WindMain
       use mesh
       use mesh_common
c
      implicit none
#ifdef DYNAMIC
       ixlo=1-nghost
#ifndef TWO_D
       iylo=1-nghost
#else
       iylo=1
#endif
       izlo=1-nghost
       ixhi=nxlocal+nghost
#ifndef TWO_D
       iyhi=nylocal+nghost
#else
       iyhi=nylocal
#endif
       izhi=nzlocal+nghost
c
       hasxlo=0
       hasxhi=0
       hasylo=0
       hasyhi=0
       if(iprocx.eq.1)then
c          ixlo=1
          hasxlo=1
       endif
       if(iprocx.eq.XPROCS)then
c          ixhi=nxlocal
          hasxhi=1
       endif
#ifndef YPERIODIC
       if(iprocy.eq.1) then
c          iylo=1
          hasylo=1
       endif
       if(iprocy.eq.YPROCS)then
c          iyhi=nylocal
          hasyhi=1
       endif
#endif
c     
c       nxlsize=nxlocal
c       nylsize=nylocal
c       nzlsize=nzlocal
#endif
c     Allocate mesh
       allocate(xc(ixlo:ixhi))
       allocate(yc(iylo:iyhi))
       allocate(zc(izlo:izhi))
c
       call WindDriver
       end
c     
c-----------------------------------------------------------------
       subroutine WindDriver
c-----------------------------------------------------------------
       use mesh
       use mesh_common
       use time
       use Properties
       use iounits
       use diags_io
#ifdef PARALLEL
       use mpistuff
#endif
       use stats
       use recycle
c
       implicit none
       double precision:: ux(IXLO:IXHI,IYLO:IYHI, IZLO:IZHI,nvar)
       double precision:: px(IXLO:IXHI,IYLO:IYHI, IZLO:IZHI)
c
       integer:: istart, maxiter, lastiter
       integer:: output_flag, binary_flag
       integer:: ndump, nplot,nslice,ndiag
       integer:: dump,checkStep
       integer:: dflag
       integer:: ipar
       integer:: timestep
       double precision::xl,xr,yl,yr,zl,zr
c
       namelist/inparams/maxiter,checkstep, output_flag, binary_flag
       namelist/dumps/ndump,nplot,nslice,ndiag
       namelist/gridbounds/xl,xr,yl,yr, zl, zr
c
       namelist/diffprops/Reynolds
c
c      read input file 
       open(16,file="wind.inp",form="formatted")
       read(16,inparams)
c      write(6,inparams)
       read(16,dumps)
c      write(6,dumps)
c      read(16,domain) 
c      write(6,domain)
       read(16,gridbounds)
c      read(16,diffprops)
c      read(16,options)
       close(16)
c
       xbound(1)=xl
       xbound(2)=xr
       ybound(1)=yl
       ybound(2)=yr
       zbound(1)=zl
       zbound(2)=zr
       lastiter=0
       istart=1
       dump=1
       dflag=1
c

       call InitIO(checkstep)
       call SetupDomain

c      write(6,*) 'After domain setup'
       call Initialize(checkStep,ux,dt,ttot,tstart,istart,lastiter)
       px = 0.d0
c      write(6,*) 'After initialization'
c

#ifdef PARALLEL
       call MPI_Barrier(comm3d, ierr)
#endif
#ifdef SILO
       call WriteSiloFile(ux,istart-1)
#endif
#ifdef HDF5
       call WriteHDF5File(ux,istart-1)
#endif
#ifdef PARALLELHDF5
       call WriteParallelHDF5File(ux,istart-1)
#endif
c      call Timing
c ---- Start time stepping; synchronise
#ifdef PARALLEL
       call MPI_Barrier(comm3d, ierr)
#endif
c
       call newdt(dt,ux)
c      

       do timeStep=istart,istart+maxiter-1,1
         if(iprocx.eq.1.and.iprocy.eq.1.and.iprocz.eq.1) then
           write(6,*) 'timeStep=',timeStep, dt, ttot
           write(ihis,*) 'timeStep=',timeStep, dt, ttot
         endif
 
         if(mod(timestep,200).eq.1)  call flushdata
#ifdef CODEA
         call outputcodeA(ux,timestep)
#endif

         call FluidSolve(ux,px,timestep)
         ttot=ttot+dt
#ifdef LES
         call Diagnostics(ux,timestep,ndiag)
#endif
c
         call newdt(dt,ux)
         if(mod(timeStep,nplot).eq.0) then
#ifdef SILO
           call WriteSiloFile(ux,timeStep)
#endif
#ifdef HDF5
           call WriteHDF5File(ux,timeStep)
#endif
#ifdef PARALLELHDF5
           call WriteParallelHDF5File(ux,timeStep)
#endif
         endif

         if(mod(timeStep,ndump).eq.0) then
c            Call WriteCheckPoint(ux,dt,ttot,timeStep)
#ifdef CODEB 
            call DumpOutFluidB(ux,timestep,dflag)
#endif
#ifdef CODEA
            call DumpOutFluidA(ux,timestep,dflag)
#endif
            dflag = 3 - dflag
         endif
#ifdef PARALLEL
         call MPI_Barrier(comm3d, ierr)
#endif
       enddo
c
       Call WrapUp(ux,dt,ttot,timestep-1)
c      call Timing
       return
       end
c     
c-----------------------------------------------------------------------
       subroutine InitIO(new)
       use mesh_common
       use iounits
#ifdef PARALLEL
       use mpistuff
#endif
       use OptionFlags
c   
       implicit none
       integer:: new
       character*25 timestamp      
c       call fdate(timestamp)
c
       if(iprocx.eq.1 .and. iprocy.eq.1 .and. iprocz.eq.1) then
c          write(*,*) 'check initio :', iprocx, iprocy, iprocz
c      append 
         if(new.ne.-1) then
           open(ihis,file='Run.history', form='formatted'
     &        ,position='Append')
           open(ieng,file='Energy.txt', form='formatted'
     &        ,position='Append')
         else
c      new open file
           open(ihis,file='Run.history', form='formatted')
           open(ieng,file='Energy.txt', form='formatted')
         endif
c
c      new comment write
         if(new.eq.-1) then
           write(ihis,*) 'NEW RUN AT: ',timestamp
         else
           write(ihis,*) 'RESTART RUN AT: ',timestamp
         endif
           write(ihis,*) 'RUN OPTIONS'
       endif
c
       return
       end
c     
c-----------------------------------------------------------------------
       subroutine Initialize
     &            (checkStep,ux,dt,ttot,tstart,istart,lastiter)
       use mesh_parms
       use mesh_common
#ifdef PARALLEL
       use mpistuff
#endif
       use PressBC
       use InflowVelBC
       use outflowBC
       use recycle       
       use stats 
c
       implicit none
       double precision:: ux(IXLO:IXHI,IYLO:IYHI, IZLO:IZHI,nvar)
       double precision:: dt, ttot, tstart
       double precision:: dtf, dts
       integer:: istart, checkStep, lastiter
c
       call SetupRKCoefficients
c     
c       initialize new communicator, comm1d, comm1dre, comm2d

c
c      Allocate Uin - BC for inflow velocity
       allocate(Uin(nghost+1,iylo:iyhi,izlo:izhi,3))
       Uin(:,:,:,1)=1.D0
       Uin(:,:,:,2)=0.D0
       Uin(:,:,:,3)=0.D0
#ifdef LES
       call allocate_stat
       call initdiagsio(checkStep)
       call allocate_LES
       call init_re
       call init_GClaw
#endif
#ifdef TURBINE
       call allocate_turbine
       call locate_turbine
#endif
c
       call subcomm
       call subcommre
       call subcomm2dyz

       if(checkStep.eq.-1) then       
        call InitFluid(ux)
        ttot = 0.d0
        tstart = 0.d0
#ifdef LES
       call init_mean(ux)
#endif
       else
        istart=istart+checkStep
#ifdef CODEB 
        call DumpInFluidB(ux,1)
#ifdef LES
       call init_mean(ux)
#endif
#endif
#ifdef CODEA
        call DumpInFluidA(ux,1)
#endif
        tstart = ttot
       endif
        call allocate_outflow
        call init_outflow(ux)
c

c  
       call newdt(dt,ux)
c
c       Allocate Pressure BCs
c        allocate(pBCx(nylocal,nzlocal,2))
c        allocate(pBCy(nxlocal,nzlocal,2))
c        allocate(pBCz(nxlocal,nylocal,2))
c
        return
        end
c
c-----------------------------------------------------------------------
       subroutine  WrapUp(ux,dt,ttot,timestep)
       use mesh_parms
       use mesh_common
       use iounits
#ifdef PARALLEL
       use mpistuff
#endif
c=======Declarations=========
       implicit none
       double precision:: ux(IXLO:IXHI,IYLO:IYHI, IZLO:IZHI,nvar)
       double precision:: dt, ttot
       integer:: timestep

c       call WriteCheckPoint(ux,dt,ttot,timeStep)
       character*25 timestamp
c       call fdate(timestamp)

c       write(ihis,*) 'End :', timestamp
c
       return
       end

c-----------------------------------------------------------------------
       subroutine Timing
       real:: extime(2)
       real:: etime, dtime
       character(len=24):: fdate
       character(len=10):: mytime, myzone
       integer:: mydate
       integer:: mydate_time(8)

#ifdef INTEL
       if(iprocx.eq.1.and.iprocy.eq.1.and.iprocz.eq.1) then
         write(18,*) iprocx, iprocy, fdate()
         write(18,*) iprocx, iprocy, etime(extime), extime(1), extime(2)
         write(18,*) iprocx, iprocy, dtime(extime), extime(1), extime(2)
       endif
#endif
#ifdef CRAY
       if(iprocx.eq.1.and.iprocy.eq.1.and.iprocz.eq.1) then
           call date(mydate)
           write(18,*) mydate
           write(18,*) timef(), second(), tsecnd()
       endif  
#endif
#ifdef SGI
       if(iprocx.eq.1.and.iprocy.eq.1.and.iprocz.eq.1) then
         write(18,*)  etime(extime), extime(1), extime(2)
         write(18,*)  dtime(extime), extime(1), extime(2)
       endif
#endif
#ifdef PC
       if(iprocx.eq.1.and.iprocy.eq.1.and.iprocz.eq.1) then
         write(18,*)  etime(extime), extime(1), extime(2)
         write(18,*)  dtime(extime), extime(1), extime(2)
       endif
#endif
       return
       end
c-----------------------------------------------------------------------
       subroutine SetupRKCoefficients
       use RKCoefficients
c     Sparlart 1991
c
        alpha(1)=29.D0/96.D0
        alpha(2)=-3.D0/40.D0
        alpha(3)=1.D0/6.D0
c
        beta(1)=37.D0/160.D0
        beta(2)=5.D0/24.D0
        beta(3)=1.D0/6.D0

c     Orlandi book
c        alpha(1)=4.d0/15.d0
c        alpha(2)=1.d0/15.d0
c        alpha(3)=1.d0/6.d0
c
c        beta(1)=4.d0/15.d0
c        beta(2)=1.d0/15.d0
c        beta(3)=1.d0/6.d0
c
        gamma(1)=8.D0/15.D0
        gamma(2)=5.D0/12.D0
        gamma(3)=3.D0/4.D0
c
        zeta(1)=-17.D0/60.D0
        zeta(2)=-5.D0/12.D0
c
c        write(6,*) 'beta(1)=',beta(1)
        return
        end subroutine SetupRKCoefficients
c-----------------------------------------------------------------------

c
      subroutine flushdata
      use iounits
      use diags_io
c
      flush(itestv)
      flush(itestv1)
      flush(itestv2)
      flush(itestv3)
      flush(itestv4)
      flush(itestv5)
      flush(itestv6)
c
c      flush(iout01)
c      flush(iout02)
c      flush(iout03)
c      flush(iout04)
c      flush(iout05)
c      flush(iout06)
c      flush(iout07)
c      flush(iout08)
c      flush(iout09)
c
      return
      end
